<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#高级特性之委托</title>
      <link href="post/1d42a619.html"/>
      <url>post/1d42a619.html</url>
      
        <content type="html"><![CDATA[<h1 id="理解委托"><a href="#理解委托" class="headerlink" title="理解委托"></a>理解委托</h1><p>委托，从字面上理解，就是托付某人去办理某事，比如，小明托付小张去买车票。<br>委托，也可以看成是一种数据类型，可以用于定义变量，但它是一种特殊的变量<br>委托定义的变量能接收的数值只能是一个方法（函数），可以理解成委托就是一个方法的指针。</p><h2 id="一、-委托声明及调用"><a href="#一、-委托声明及调用" class="headerlink" title="一、    委托声明及调用"></a>一、    委托声明及调用</h2><p>语法：<br>访问修饰符 delegate 返回类型 委托名(参数列表);<br>比如：</p><pre><code>public delegate void BuyTicketEventHandler();</code></pre><p>其中delegate 是关键字<br>这就是委托，就这么简单，看看和我们一般的方法有什么区别呢？</p><pre><code>public void BuyTicket()&#123;    //方法体&#125;</code></pre><p>同学们看到区别了吗？<br>在现实生活中，委托只是个命令，做事情是别人，而在程序世界里委托只是存储了各个方法的地址，而它自己却是什么也不做的。<br>那我们就把刚才那个小明委托小张去买车票的现实生活场景，怎么在程序世界里体现呢？</p><pre><code>public class MrZhang&#123;    //2）根据委托定义的函数原型编写需要的方法   买票的悲情人物是小张      public void BuyTicket()    &#123;        Console.WriteLine(&quot;苍天啊大地啊，怎么总是让我去排队买票？&quot;);    &#125;&#125;//1）声明一个委托，其实就是一个“命令”   ，定义一个函数的原型 public delegate void BuyTicketEventHandler();public class MrMing&#123;    static void Main(string[] args)&#123;MrZhang zhang = new MrZhang();    //这里就是具体阐述这个命令是干什么的，本例是zhang.BuyTicket“小张买车票”//3）委托在使用前必须实例化，实例化的试时候需要指明默认的方法         BuyTicketEventHandler myDelegate =             new BuyTicketEventHandler(zhang.BuyTicket);        //这时候委托被附上了具体的方法，可以执行了      //4）通过委托调用方法，而不是直接调用方法        myDelegate();    &#125;&#125;</code></pre><p><strong>注：委托的参数和返回类型，都要和其要具体委托的方法要一致！比如：</strong></p><pre><code>public delegate void BuyTicketEventHandler();public void BuyTicket()&#123;Console.WriteLine(&quot;苍天啊大地啊，怎么总是让我去排队买票？&quot;);&#125;</code></pre><p>在现实生活中，小明叫小张买完车票之后，可能接着又让他带张电影票，那用我们的委托该怎么表述呢？要用到委托链。</p><pre><code>public class MrZhang&#123;    //买票的悲情人物是小张    public void BuyTicket()    &#123;        Console.WriteLine(&quot;苍天啊大地啊，怎么总是让我去排队买票？&quot;);&#125;    public void BuyMovieTicket()    &#123;        Console.WriteLine(&quot;单身狗的世界里没有电影&quot;);    &#125;&#125;//声明一个委托，其实就是一个“命令”    public delegate void BuyTicketEventHandler();public class MrMing&#123;    static void Main(string[] args)&#123;MrZhang zhang = new MrZhang();    //这里就是具体阐述这个命令是干什么的，本例是zhang.BuyTicket“小张买车票”         BuyTicketEventHandler myDelegate =             new BuyTicketEventHandler(zhang.BuyTicket);         //5）委托对象所关联的方法可以动态地变化（非常关键）myDelegate += zhang.BuyMovieTicket;         //这时候委托被附上了具体的方法，可以执行了         myDelegate();    &#125;&#125;</code></pre><p>这时候这个委托就相当于发布了两条指令：先是买车票，然后是买电影票！<br>    通过委托调用方法的多种写法：<br>    写法一：</p><pre><code>BuyTicketEventHandler myDelegate =    new BuyTicketEventHandler(zhang.BuyTicket);myDelegate += zhang.BuyMovieTicket;</code></pre><pre><code>写法二：</code></pre><pre><code>BuyTicketEventHandler myDelegate;myDelegate = zhang.BuyTicket;myDelegate += zhang.BuyMovieTicket;</code></pre><p>这样的写法是错误的：</p><pre><code>BuyTicketEventHandler myDelegate =    new BuyTicketEventHandler();myDelegate = zhang.BuyTicket;myDelegate += zhang.BuyMovieTicket;</code></pre><p>错误原因：委托不包括0个参数的构造函数</p><h2 id="二、-把委托做为方法的参数进行传递"><a href="#二、-把委托做为方法的参数进行传递" class="headerlink" title="二、    把委托做为方法的参数进行传递"></a>二、    把委托做为方法的参数进行传递</h2><p>编写一个数学类，用于计算两个double类型的数字之和：</p><pre><code>public class MyMath&#123;    private double Add(double a, double b)    &#123;        return a + b;    &#125;    public double Calc(double a, double b)    &#123;        return Add(a, b);    &#125;&#125;</code></pre><p>调用：</p><pre><code>public class Program&#123;    static void Main(string[] args)    &#123;        MyMath math = new MyMath();        Console.WriteLine(math.Calc(10, 20));    &#125;&#125;</code></pre><p>如果我们要扩充这个数学类的功能，使之能用于计算两个double类型的数字之差，则需要修改MyMath类，添加一个Sub方法：</p><pre><code>public class MyMath&#123;    private double Add(double a, double b)    &#123;        return a + b;    &#125;    private double Sub(double a, double b)    &#123;        return a - b;    &#125;    public double Calc(double a, double b)    &#123;        return Add(a, b);    &#125;&#125;</code></pre><p>这时Calc方法需要进行修改了，要不然每次都是调用Add方法。那么该如何判断是调用Add方法还是Sub方法呢？我们引进一个枚举类型：</p><pre><code>public enum MyType &#123; Add, Sub&#125;</code></pre><p>然后修改Calc方法，代码清单如下：</p><pre><code>public double Calc(double a, double b, MyType myType)&#123;    switch (myType)    &#123;         case MyType.Add:            return Add(a, b);        case MyType.Sub:            return Sub(a, b);        default:            return Add(a, b);    &#125;&#125;</code></pre><p>Program类也需要做出相应的修改：</p><pre><code>public class Program&#123;    static void Main(string[] args)    &#123;        MyMath math = new MyMath();        Console.WriteLine(math.Calc(10, 20, MyType.Sub));    &#125;&#125;</code></pre><p>OK，尽管这样解决了问题，估计同学们也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加乘法、除法，那么我们不得不反复修改Calc方法。<br>好的，我们来看看Calc方法的参数签名：<br>Calc(double a, double b, MyType myType)<br>其中double是参数类型，a是参数变量。当我们把1赋给它时，它就代表“1”这个值，把2赋给它时，它就代表“2”这个值，然后我们在方法体可以对a进行其他操作。<br>想想，如果Calc方法接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 Add的时候，它代表着 Add() 这个方法；当我们给它赋值Sub 的时候，它又代表着Sub()方法。我们将这个参数变量命名为 Opt，那么不是可以如同给a赋值时一样，在调用 Calc()方法的时候，给这个Opt 参数也赋上值么(Add或者Sub等)？然后，我们在方法体内，也可以像使用别的参数一样使用Opt。但是，由于Opt代表着一个方法，它的使用方式应该和它被赋的方法(比如Add)是一样的，比如：<br>Opt(a, b)</p><p>好了，有了思路，我们就来修改Calc方法，应该是这个样子：<br>public double Calc(double a, double b, *** Opt){<br>    Opt(a, b);<br>}</p><p>注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写Calc方法，就出现了一个大问题：这个代表着方法的Opt参数应该是什么类型的？<br>注意：这里已不再需要枚举了，因为在给Opt赋值的时候动态地决定使用哪个方法，是Add还是 Sub。<br>聪明的同学们应该已经想到了，是委托该出场的时候了。</p><p>定义一个与Add方法和Sub方法具有相同方法签名的委托：</p><pre><code>public delegate double CalcEventHandler(double a, double b);</code></pre><p>把Calc方法的Opt参数的类型声明为该委托：</p><pre><code>public double Calc(double a, double b,     CalcEventHandler myDelegate)&#123;    return myDelegate(a, b);&#125;</code></pre><p>现在在Program类中的调用方式调整如下：</p><pre><code>public class Program&#123;    static void Main(string[] args)    &#123;        MyMath math = new MyMath();        Console.WriteLine(math.Calc(10, 20, math.Add));        Console.WriteLine(math.Calc(10, 20, math.Sub));        //如果要计算除法呢？        //在MyMath类中定义一个名为Div的方法     &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#高级特性之扩展方法</title>
      <link href="post/17201.html"/>
      <url>post/17201.html</url>
      
        <content type="html"><![CDATA[<h1 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h1><p>&emsp;&emsp;为扩展指定类型的功能而编写的方法称为扩展方法。扩展方法可以带任意数量、类型的参数，并返回任意类型。<br>&emsp;&emsp;扩展方法被定义为静态方法，但它们是通过实例方法语法进行调用的。它们的第一个参数指定该方法作用于哪个类型，并且该参数以 this 修饰符为前缀。<br>&emsp;&emsp;要创建和使用扩展方法，必须：</p><ol><li>扩展方法必须在静态类中定义</li><li>扩展的方法要声明为静态方法</li><li>扩展方法第一个参数以 this 修饰符为前缀</li></ol><h2 id="一、扩展方法"><a href="#一、扩展方法" class="headerlink" title="一、扩展方法"></a>一、扩展方法</h2><ol><li><p>定义扩展方法<br>不带参数的扩展方法定义<br>语法：static 方法名(this 目标类型 目标类型参数)<br>示例：  </p><pre><code>public static int GetAvg(this int sum)&#123;  return sum / 5;&#125;</code></pre><p>this    修饰符，this就是为了表示这是个扩展方法。只是作为一般静态方法和扩展方法的一种区分，对扩展方法可以理解为它是调用静态方法的一种新语法<br>int     即为int类型扩展出了GetAvg方法<br>sum         变量名，可以自定义<br>带参数的扩展方法定义<br>语法：static 方法名(this 目标类型 目标类型参数,参数类型，参数名,…)<br>示例：</p><pre><code>public static int GetAvg(this int sum,int num)&#123;  return sum / num;&#125;</code></pre></li><li><p>   调用扩展方法<br>方式1：通过变量名.扩展方法名();</p><pre><code>int sum = 500;      //总分int avg = sum.GetAvg();      //int avg2 =sum.GetAvg(5);Console.WriteLine(&quot;平均分是：&#123;0&#125;&quot;, avg); </code></pre><p>方式2：通过类名.扩展方法名();</p><pre><code>int sum = 500;      //总分int avg = ExtendMethod.GetAvg(sum); //int avg2 = ExtendMethod.GetAvg(sum,5); Console.WriteLine(&quot;平均分是：&#123;0&#125;&quot;, avg);</code></pre></li></ol><h2 id="二、扩展方法与实例方法"><a href="#二、扩展方法与实例方法" class="headerlink" title="二、扩展方法与实例方法"></a>二、扩展方法与实例方法</h2><p>实例方法优先于扩展方法，意思是当类本身的方法与扩展方法重名时，类本身的方法被优先调用</p><pre><code>class Teacher&#123;        public void MyMethod()        &#123;                Console.WriteLine(&quot;实例方法&quot;);        &#125;&#125;class ExtendMethod &#123;        public static void MyMethod(this Teacher t)        &#123;                Console.WriteLine(&quot;扩展方法&quot;);        &#125; &#125;</code></pre><p>测试类：</p><pre><code>static void Main(string[] args)&#123;        Teacher teacher = new Teacher();        teacher.MyMethod();&#125;</code></pre><p>结果：</p><pre><code>    实例方法</code></pre><p>在这种情况下调用扩展方法的唯一方法是通过正常的静态语法：</p><pre><code>ExtendMethod.MyMethod(teacher);</code></pre><p>结果：</p><pre><code>    扩展方法</code></pre><h2 id="三、扩展方法与扩展方法"><a href="#三、扩展方法与扩展方法" class="headerlink" title="三、扩展方法与扩展方法"></a>三、扩展方法与扩展方法</h2><p>如果在两个静态类中定义相同的扩展方法，则扩展方法必须作为普通静态方法调用，以消除调用方法的歧义。</p><pre><code> class ExtendMethod &#123;     public static int GetAvg(this int sum)     &#123;                return sum / 5;      &#125; &#125; class ExtendMethod2 &#123;      public static int GetAvg(this int sum)      &#123;                return sum / 5;      &#125; &#125;</code></pre><p>测试类：</p><pre><code>static void Main(string[] args)&#123;      int sum = 500;int avg=sum.GetAvg();   //调用不明确Console.WriteLine(avg);&#125;</code></pre><p>必须明确指定调用哪个静态类中的扩展方法</p><pre><code>int sum = 500;int avg = ExtendMethod.GetAvg(sum);</code></pre><h2 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h2><ol><li>实验目的<br>扩展System.Object类的功能，创建ToInt()、ToDouble()、ToDateTime()等方法（类似于ToString()方法）。</li><li>实验步骤<br>创建如下的数据表：  <pre><code>create table Student( Id            int, Name        nvarchar(20), Birthday    datetime, Score        int)</code></pre></li></ol><p>1)插入两条测试数据</p><pre><code>insert into Student(Id,Name,Birthday,Score) values(1,’张三’,‘2002-1-1’,100)insert into Student(Id) values(2)</code></pre><p>2）创建一个控制台应用程序，试着循环输出Student表中的所有记录；<br>3）我们发现，数据表中的null字段，在C#中表示为DBNull，试图将DBNull转换为int、DateTime等数据类型时会出错；<br>4）编写ToInt()、ToDateTime()等扩展方法：</p><pre><code>static class MyExtension&#123;    static public int? ToInt(this object value)    &#123;        if (value is DBNull)            return null;        else            return Convert.ToInt32(value);    &#125;    static public DateTime? ToDateTime(this object value)    &#123;        if (value is DBNull)            return null;        else            return Convert.ToDateTime(value);    &#125;&#125;</code></pre><p>5）Int?<br>表示可空类型，就是一种特殊的值类型，它的值可以为null</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#高级特性之初始化器和匿名类型</title>
      <link href="post/31985.html"/>
      <url>post/31985.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象和集合的初始化器"><a href="#对象和集合的初始化器" class="headerlink" title="对象和集合的初始化器"></a>对象和集合的初始化器</h1><p>对象的初始化器提供了一种简洁的语法来创建和初始化一个对象<br>集合的初始化器提供了一种简洁的语法来创建和填充集合。</p><p>&emsp;&emsp;同学们还记得数组的使用方法吗？ </p><pre><code>int[] arr1 = new int[3];arr1[0] = 10;arr1[1] = 20;arr1[2] = 30;int[] arr2 = new int[] &#123; 10, 20, 30 &#125;;</code></pre><h2 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h2><p>有如下的一个类：</p><pre><code>    class Student    &#123;        public int Id &#123; get; set; &#125;        public string Name &#123; get; set; &#125;        public DateTime Birthday &#123; get; set; &#125;    &#125;</code></pre><p>用普通方法创建和初始化一个对象</p><pre><code>    Student stu = new Student();    stu.Id = 1;    stu.Name = &quot;张三&quot;;    stu.Birthday = Convert.ToDateTime(&quot;1996-1-1&quot;);</code></pre><p>用对象初始化器创建和初始化一个对象</p><pre><code>    Student stu = new Student &#123; Id = 1, Name = &quot;张三&quot;,         Birthday = Convert.ToDateTime(&quot;1996-1-1&quot;) &#125;;</code></pre><p>&emsp;&emsp;对象初始化器允许在程序中通过声明的方式直接给对象属性进行数值的初始化，而不必刻意建立有参数的构造函数<br>对象初始化器与构造方法的异同点<br> &emsp;相同点:都可以完成对象属性的初始化<br> &emsp;不同点:</p><ol><li><p>构造函数具有强制性，而对象初始化器没有强制性</p></li><li><p>前者只能完成属性初始化，而构造函数可以完成任何需要的初始化<br>工作，如对象创建</p><p>&emsp;&emsp;对象初始化器时在创建对象的时候使用，而构造方法是写在类里面</p></li></ol><p>&emsp;&emsp;注意：使用初始化器时，要求相关的类中必须要有一个无参构造函数★★★★★  </p><h2 id="集合初始化器"><a href="#集合初始化器" class="headerlink" title="集合初始化器"></a>集合初始化器</h2><p>用上面的类来创建和填充一个具有三个对象的泛型集合<br>普通方法</p><pre><code>    Student stu1 = new Student();    stu1.Id = 1;    stu1.Name = &quot;张三&quot;;    stu1.Birthday = Convert.ToDateTime(&quot;1996-1-1&quot;);    Student stu2 = new Student();    stu2.Id = 2;    stu2.Name = &quot;李四&quot;;    stu2.Birthday = Convert.ToDateTime(&quot;1996-1-2&quot;);    Student stu3 = new Student();    stu3.Id = 3;    stu3.Name = &quot;王五&quot;;    stu3.Birthday = Convert.ToDateTime(&quot;1996-1-3&quot;);    List&lt;Student&gt; list = new List&lt;Student&gt;();    list.Add(stu1);    list.Add(stu2);     list.Add(stu3);</code></pre><p>集合初始化器</p><pre><code>List&lt;Student&gt; list = new List&lt;Student&gt;&#123;    new Student&#123;Id = 1, Name = &quot;张三&quot;, Birthday = Convert.ToDateTime(&quot;1996-1-1&quot;)&#125;,    new Student&#123;Id = 2, Name = &quot;李四&quot;, Birthday = Convert.ToDateTime(&quot;1996-1-2&quot;)&#125;,    new Student&#123;Id = 3, Name = &quot;王五&quot;, Birthday = Convert.ToDateTime(&quot;1996-1-3&quot;)&#125;,&#125;;</code></pre><p>注意：用初始化器，必须确保相关的类有一个公有的无参构造方法如果你在相关类中写了有参构造方法而将它的默认无参构造方法覆盖了，并且没有提供一个新的无参构造方法，那么使用对象初始化器编译的时候是不会通过的   </p><h2 id="嵌套的初始化器"><a href="#嵌套的初始化器" class="headerlink" title="嵌套的初始化器"></a>嵌套的初始化器</h2><p>考虑如下的两个类：</p><pre><code>    class Address    &#123;        public string Province &#123; get; set; &#125;        public string City &#123; get; set; &#125;        public string County &#123; get; set; &#125;        public string Street &#123; get; set; &#125;    &#125;    class Student    &#123;        public int Id &#123; get; set; &#125;        public string Name &#123; get; set; &#125;        public DateTime Birthday &#123; get; set; &#125;        public Address Address &#123; get; set; &#125;    &#125;</code></pre><p>&emsp;&emsp;&emsp;&emsp;请注意Student类中的Address属性的数据类型</p><p>&emsp;&emsp;&emsp;&emsp;用对象初始化器初始化一个学员对象的代码如下：</p><pre><code>    Student stu = new Student    &#123;        Id = 1,        Name = &quot;张三&quot;,        Birthday = Convert.ToDateTime(&quot;1996-1-1&quot;),        Address = new Address        &#123;            Province = &quot;湖南省&quot;,            City = &quot;长沙市&quot;,            County = &quot;雨花区&quot;,            Street = &quot;香樟路601号&quot;        &#125;    &#125;;</code></pre><p>思考：用普通方法如何创建并初始化一个学员对象？</p><hr><h1 id="类型推断及匿名类型"><a href="#类型推断及匿名类型" class="headerlink" title="类型推断及匿名类型"></a>类型推断及匿名类型</h1><p><strong><em>一、类型推断</em></strong><br>    思考：在JavaScript中如何定义一个变量？</p><pre><code>var i = 5;var s = &quot;abc&quot;;var b = true;var now = new Date();var arr = new Array();i = &quot;欧柏泰克软件学院&quot;;s = 123;</code></pre><p>JavaScript属于弱类型化语言，而C#属于强类型化语言。</p><p>C#中的关键字var，可以像JavaScrpit一样的方式来声明变量，比如：</p><pre><code>    var i = 5;    var s = &quot;abc&quot;;    Console.WriteLine(i);    Console.WriteLine(s);</code></pre><p>&emsp;&emsp;var关键字用来隐式地声明一个数据类型，var不是一种新的数据类型，变量类型是在编译期确定的，而不是在运行时确定的，它是依赖于编译器根据所赋的值来自动确定变量的类型；并且一个变量一旦赋值，在后续的代码中就不能更改其数据类型。<br>&emsp;&emsp;如果编译器无法确定用var声明的变量类型，那代码就无法编译，因此，在用var声明变量时，必须同时初始化该变量，因为如果没有初始化值，编译器就不能确定变量的类型，比如下面的代码就无法编译：</p><pre><code>var i;</code></pre><p>&emsp;&emsp;还可以用var关键字来声明并初始化数组：</p><pre><code>var arr = new[] &#123; 10, 20, 30 &#125;;</code></pre><p>&emsp;&emsp;注意：<br>&emsp;&emsp;&emsp;&emsp;对于一些名称比较长的类，类实例化的时候，可以用var关键字声明的变量接收  </p><ol><li>var 类型会被编译器根据初始值的类型推断出具体的类型;    </li><li>var 类型的局部变量必须赋予初始值</li><li>无法将null赋值给隐式类型的局部变量;</li><li>var 类型变量的定义必须是在方法中或者在属性get、set 访问器中；</li><li>var 不能做方法的参数；</li><li>不能当作返回值类型；</li><li>语句中只能声明一次变量，声明后不能更改类型；</li></ol><p><strong><em>二、匿名类型</em></strong><br>    在编写数据库应用程序中，我们需要编写实体类来对应数据库中的数据表，一个实体类对应于一个数据表。这些实体类往往只有一系列的属性，一个属性对应一个字段。比如：</p><pre><code>    class Address    &#123;        public string Province &#123; get; set; &#125;        public string City &#123; get; set; &#125;        public string County &#123; get; set; &#125;        public string Street &#123; get; set; &#125;    &#125;</code></pre><p>这样的实体类仅仅用于存储结构化的数据，一个实例对于于数据表中的一行。编写这样的类往往比较单调。我们可以匿名类型来简化这一编程模型。其原理是使用C#编译器根据要存储的数据自动创建类型，而不是定义简单的数据存储类型。<br>&emsp;&emsp;可按如下的方式来实例化前面的Address类型：</p><pre><code>    Address address = new Address     &#123;         Province = &quot;湖南省&quot;,        City = &quot;长沙市&quot;,        County = &quot;岳麓区&quot;,        Street = &quot;桐梓坡路579号&quot;    &#125;;</code></pre><p>也可以使用匿名类型：</p><pre><code>    var address = new     &#123;         Province = &quot;湖南省&quot;,        City = &quot;长沙市&quot;,        County = &quot;雨花区&quot;,        Street = &quot;桐梓坡路579号&quot;    &#125;;</code></pre><p>区别有两点：第一，使用了var关键字；第二，在new的关键字后面没有指定类型名称，这是编译器确定我们要使用匿名类型的节奏。<br>    在IDE中，可以智能感知出匿名类型的成员：</p><pre><code>    Console.WriteLine(&quot;省：&#123;0&#125;&quot;, address.Province);    Console.WriteLine(&quot;市：&#123;0&#125;&quot;, address.City);    Console.WriteLine(&quot;县：&#123;0&#125;&quot;, address.County);    Console.WriteLine(&quot;街道：&#123;0&#125;&quot;, address.Street);</code></pre><p>&emsp;&emsp;看得出来，Province、City、County、Street表现出来的是属性成员。<br>&emsp;&emsp;注意：<br>通过匿名类创建的属性属于只读属性。这意味着要修改属性的值，就不能用匿名类型！<br>new关键字和var配合使用<br>匿名类只能添加对象的属性</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
